import React, { useState, useEffect, useRef, useCallback } from "react";
import {
  ArrowDown,
  ArrowUp,
  Calendar,
  ChevronDown,
  Clock,
  DollarSign,
  BarChart,
  RefreshCw,
  Share2,
  Star,
  Settings,
  Maximize2,
  TrendingUp,
  Volume2,
  Activity,
  Wifi,
  WifiOff,
  X,
} from "lucide-react";
import TradingBinance from "../components/common/TradingBinance";
import { FormattedMessage, FormattedNumber } from "react-intl";
import TradingViewChart from "../components/common/TradingViewChart";
import { CandlestickData } from "lightweight-charts";
import { fetchHistoricalKlines } from "../utils/fetchKline";
import { ExtendedCandle } from "../utils/types";
import { Order } from "../utils/types";
import SymbolDropdown from "../components/symboldropdown/SymbolDropdown";
import symbolList from "../utils/symbolList";
import TradingForm from "../components/common/TradingForm";
import { useMiniTickerStore } from "../utils/miniTickerStore";
import { binanceWS } from "../components/binancewebsocket/BinanceWebSocketService";
import { toast } from "react-toastify";
import { AlertTriangle } from "lucide-react";
import OrderOpenHistory from "../components/orderlayout/OrderOpenHistory";
import SettingControl from "../components/common/controlsetting/SetiingControl";
import { BinanceAccount } from "../utils/types";
import BinanceAccountSelector from "../components/common/BinanceAccountSelector";
import { useAuth } from "../context/AuthContext";
import { User } from "../utils/types";
import { PositionData,FloatingInfo } from "../utils/types";
import PositionFunction from "../components/common/PositionFunction";
// Tr·∫°ng th√°i k·∫øt n·ªëi WS
type ConnectionStatus = "connecting" | "connected" | "disconnected" | "error";

// Lo·∫°i th·ªã tr∆∞·ªùng
type MarketType = "spot" | "futures" ;

export type ChartSettings = {
  quickOrder: boolean;      // L·ªánh nhanh
  pendingOrders: boolean;   // L·ªánh ch·ªù
  positionTag: boolean;     // V·ªã th·∫ø (Floating)
  orderHistory: boolean;    // L·ªãch s·ª≠ ƒë·∫∑t l·ªánh
  breakEven: boolean;       // Gi√° h√≤a v·ªën
  liquidation: boolean;     // Gi√° thanh l√Ω
  alerts: boolean;          // C·∫£nh b√°o gi√°
  priceLine: boolean;       // ƒê∆∞·ªùng gi√°
  scale: boolean;           // Thang ƒëo
};

// D·ªØ li·ªáu th·ªã tr∆∞·ªùng
interface KlineData {
  symbol: string;
  interval: string;
  openTime: number;
  closeTime: number;
  open: string;
  high: string;
  low: string;
  close: string;
  volume: string;
  trades: number;
  baseAssetVolume: string;
  quoteAssetVolume: string;
}

interface TickerData {
  symbol: string;
  priceChange: string;
  priceChangePercent: string;
  weightedAvgPrice: string;
  prevClosePrice: string;
  lastPrice: string;
  lastQty: string;
  bidPrice: string;
  askPrice: string;
  openPrice: string;
  highPrice: string;
  lowPrice: string;
  volume: string;
  quoteVolume: string;
  openTime: number;
  closeTime: number;
  count: number;
}

interface OrderBookEntry {
  price: string;
  quantity: string;
  total?: number;
}

interface OrderBookData {
  symbol: string;
  lastUpdateId: number;
  bids: OrderBookEntry[];
  asks: OrderBookEntry[];
}

interface TradeData {
  symbol: string;
  tradeId: number;
  price: string;
  qty: string;
  time: number;
  isBuyerMaker: boolean;
}

interface BookTickerData {
  symbol: string;
  bidPrice: string;
  bidQty: string;
  askPrice: string;
  askQty: string;
  updateId: number;
}

interface MiniTickerData {
  symbol: string;
  close: string;
  open: string;
  high: string;
  low: string;
  volume: string;
  quoteVolume: string;
  eventTime: number;
  percentChange: string;
}

// Account (cho stream private)
interface AccountInfo {
  makerCommission: number;
  takerCommission: number;
  buyerCommission: number;
  sellerCommission: number;
  canTrade: boolean;
  canWithdraw: boolean;
  canDeposit: boolean;
  balances: Array<{
    asset: string;
    free: string;
    locked: string;
  }>;
}

interface OrderUpdate {
  symbol: string;
  orderId: number;
  orderListId: number;
  clientOrderId: string;
  price: string;
  origQty: string;
  executedQty: string;
  cummulativeQuoteQty: string;
  status: string;
  timeInForce: string;
  type: string;
  side: string;
  stopPrice: string;
  icebergQty: string;
  time: number;
  updateTime: number;
  isWorking: boolean;
}

interface Subscription {
  id: string;
  action: string;
  symbol?: string;
  market?: MarketType;
  interval?: string;
  levels?: string;
  speed?: string;
  connectionId?: string;
  timestamp: number;
}
interface SymbolItem {
  symbol: string;
  price: number;
  percentChange: number;
  volume: number;
}

interface Position {
  symbol: string;
  positionSide: string;
  positionAmt: string;
}
interface Order {
  orderId: number;
  symbol: string;
  status: string;
  positionSide: 'LONG' | 'SHORT' | 'BOTH';
}

// WS public tu·ª≥ ch·ªânh cho b·∫£ng ph·ª• (kline/ticker/depth/trade/miniTicker)
class CustomWebSocketService {
  private ws: WebSocket | null = null;
  private subscriptions: Map<string, Subscription> = new Map();
  private callbacks: Map<string, (data: any) => void> = new Map();
  private isAuthenticated = false;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectDelay = 1000;
  private authToken: string | null = null;
  private binanceAccountId: number | null = null;
  private isConnected = false;
  public onStatusChange: (status: ConnectionStatus) => void = () => {};

  constructor() {
    this.connect();
  }

  private messageQueue: any[] = [];

  private connect() {
    try {
      this.onStatusChange("connecting");

      this.ws = new WebSocket(
        "ws://45.77.33.141/w-binance-socket/signalr/connect"
      );

      this.ws.onopen = () => {
        console.log("‚úÖ WebSocket connected");
        this.onStatusChange("connected");
        this.isConnected = true;

        // g·ª≠i l·∫°i c√°c message ƒë√£ queue
        this.messageQueue.forEach((msg) => {
          if (this.ws?.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(msg));
          }
        });
        this.messageQueue = [];

        // ƒëƒÉng k√Ω m·∫∑c ƒë·ªãnh t·ªëi thi·ªÉu
        const subs = [
          { action: "subscribePublicTicker", symbol: "BTCUSDT" },
          { action: "subscribePublicKline", symbol: "BTCUSDT", interval: "1m" },
          { action: "subscribePublicTrade", symbol: "BTCUSDT" },
        ];
        subs.forEach((msg) => this.sendMessage(msg));
      };

      this.ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          this.handleMessage(data);
        } catch (error) {
          console.error("‚ùå Error parsing message:", error);
        }
      };

      this.ws.onerror = (error) => {
        console.error("‚ùå WebSocket error:", error);
        this.onStatusChange("error");
        this.isConnected = false;
      };

      this.ws.onclose = () => {
        console.warn("üîå WebSocket closed. Reconnecting...");
        this.onStatusChange("disconnected");
        this.isConnected = false;
        this.attemptReconnect();
      };
    } catch (error) {
      console.error("‚ùå Failed to connect WebSocket:", error);
      this.onStatusChange("error");
    }
  }

  private handleMessage(data: any) {
    if (data.action) {
      switch (data.action) {
        case "klineUpdate":
          this.handleKlineData(data);
          break;
        case "tickerUpdate":
          this.handleTickerData(data);
          break;
        case "depthUpdate":
          this.handleDepthData(data);
          break;
        case "tradeUpdate":
          this.handleTradeData(data);
          break;
        case "bookTickerUpdate":
          this.handleBookTickerData(data);
          break;
        case "miniTickerUpdate":
          this.handleMiniTickerData(data);
          break;
        case "accountUpdate":
          this.handleAccountData(data);
          break;
        case "orderUpdate":
          this.handleOrderData(data);
          break;
        case "subscriptionList":
          this.handleSubscriptionList(data);
          break;
        default:
          // kh√¥ng c·∫ßn c·∫£nh b√°o
          break;
      }
    } else if (data.type) {
      switch (data.type) {
        case "kline":
          this.handleKlineData(data);
          break;
        case "ticker":
          this.handleTickerData(data);
          break;
        case "depth":
          this.handleDepthData(data);
          break;
        case "trade":
          this.handleTradeData(data);
          break;
        case "bookTicker":
          this.handleBookTickerData(data);
          break;
        case "miniTicker":
          this.handleMiniTickerData(data);
          break;
        case "account":
          this.handleAccountData(data);
          break;
        case "order":
          this.handleOrderData(data);
          break;
        case "connection_status":
          break;
        case "welcome":
          break;
        default:
          break;
      }
    }
  }

  private handleKlineData(data: any) {
    const callback = this.callbacks.get("kline");
    if (!callback) return;

    const kline = data.data;

    if (
      kline &&
      kline.open !== undefined &&
      kline.high !== undefined &&
      kline.low !== undefined &&
      kline.close !== undefined &&
      kline.volume !== undefined
    ) {
      callback({
        symbol: kline.symbol || "",
        interval: kline.interval || "",
        openTime: kline.openTime,
        closeTime: kline.closeTime,
        open: kline.open,
        high: kline.high,
        low: kline.low,
        close: kline.close,
        volume: kline.volume,
        trades: kline.trades || 0,
        baseAssetVolume: kline.baseAssetVolume || "",
        quoteAssetVolume: kline.quoteAssetVolume || "",
      });
    } else {
      console.warn("‚ö†Ô∏è Invalid kline data received:", kline);
    }
  }

  private handleTickerData(data: any) {
    const callback = this.callbacks.get("ticker");
    if (callback && data.data) {
      callback(data.data);
    }
  }

  private handleDepthData(data: any) {
    const callback = this.callbacks.get("depth");
    if (callback && data.data) {
      callback(data.data);
    }
  }

  private handleTradeData(data: any) {
    const callback = this.callbacks.get("trade");
    if (callback && data.data) {
      callback(data.data);
    }
  }

  private handleBookTickerData(data: any) {
    const callback = this.callbacks.get("bookTicker");
    if (callback && data.data) {
      callback(data.data);
    }
  }

  private handleMiniTickerData(data: any) {
    const symbol = data?.data?.symbol;
    const callback = this.callbacks.get(`miniTicker_${symbol}`);
    if (callback && data.data) {
      callback(data.data);
    }
  }

  private handleAccountData(data: any) {
    const callback = this.callbacks.get("account");
    if (callback && data.data) {
      callback(data.data);
    }
  }

  private handleOrderData(data: any) {
    const callback = this.callbacks.get("orders");
    if (callback && data.data) {
      callback(data.data);
    }
  }

  private handleSubscriptionList(data: any) {
    console.log("üìã Active subscriptions:", data.subscriptions);
  }

  private attemptReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = this.reconnectDelay * this.reconnectAttempts;
      console.log(
        `üîÑ Reconnecting... Attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts} in ${delay}ms`
      );
      setTimeout(() => {
        this.connect();
      }, delay);
    } else {
      console.error("‚ùå Max reconnection attempts reached");
      this.onStatusChange("error");
    }
  }

  private resubscribeAll() {
    this.subscriptions.forEach((subscription) => {
      this.sendMessage(subscription);
    });
  }

  private sendMessage(message: any) {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    } else {
      this.messageQueue.push(message);
    }
  }

  public setStatusCallback(callback: (status: ConnectionStatus) => void) {
    this.onStatusChange = callback;
  }

  public setAuthToken(token: string, binanceAccountId: number) {
    this.authToken = token;
    this.binanceAccountId = binanceAccountId;
    this.isAuthenticated = true;
  }

  // PUBLIC STREAMS
  public subscribeKline(
    symbol: string,
    interval: string,
    market: MarketType = "spot",
    callback?: (data: any) => void
  ) {
    const subscriptionId = `kline_${symbol}_${interval}_${market}`;
    const message = {
      action: "subscribeKline",
      market,
      symbol,
      interval,
    };

    if (callback) {
      this.callbacks.set("kline", callback);
    }

    this.subscriptions.set(subscriptionId, {
      id: subscriptionId,
      action: "subscribeKline",
      symbol,
      market,
      interval,
      timestamp: Date.now(),
    });

    this.sendMessage(message);
    return subscriptionId;
  }

  public subscribeTicker(
    symbol: string,
    market: MarketType = "spot",
    callback?: (data: any) => void
  ) {
    const subscriptionId = `ticker_${symbol}_${market}`;
    const message = {
      action: "subscribeTicker",
      market,
      symbol,
    };

    if (callback) {
      this.callbacks.set("ticker", callback);
    }

    this.subscriptions.set(subscriptionId, {
      id: subscriptionId,
      action: "subscribeTicker",
      symbol,
      market,
      timestamp: Date.now(),
    });

    this.sendMessage(message);
    return subscriptionId;
  }

  public subscribeDepth(
    symbol: string,
    levels: string = "20",
    speed: string = "1000ms",
    market: MarketType = "spot",
    callback?: (data: any) => void
  ) {
    const subscriptionId = `depth_${symbol}_${levels}_${speed}_${market}`;
    const message = {
      action: "subscribePublicDepth",
      symbol,
      levels,
      speed,
    };

    if (callback) {
      this.callbacks.set("depth", callback);
    }

    this.subscriptions.set(subscriptionId, {
      id: subscriptionId,
      action: "subscribePublicDepth",
      symbol,
      market,
      levels,
      speed,
      timestamp: Date.now(),
    });

    this.sendMessage(message);
    return subscriptionId;
  }

  public subscribeTrade(
    symbol: string,
    market: MarketType = "spot",
    callback?: (data: any) => void
  ) {
    const subscriptionId = `trade_${symbol}_${market}`;
    const message = {
      action: "subscribePublicTrade",
      symbol,
    };

    if (callback) {
      this.callbacks.set("trade", callback);
    }

    this.subscriptions.set(subscriptionId, {
      id: subscriptionId,
      action: "subscribePublicTrade",
      symbol,
      market,
      timestamp: Date.now(),
    });

    this.sendMessage(message);
    return subscriptionId;
  }

  public subscribeBookTicker(
    symbol: string,
    market: MarketType = "spot",
    callback?: (data: any) => void
  ) {
    const subscriptionId = `bookTicker_${symbol}_${market}`;
    const message = {
      action: "subscribePublicBookTicker",
      symbol,
    };

    if (callback) {
      this.callbacks.set("bookTicker", callback);
    }

    this.subscriptions.set(subscriptionId, {
      id: subscriptionId,
      action: "subscribePublicBookTicker",
      symbol,
      market,
      timestamp: Date.now(),
    });

    this.sendMessage(message);
    return subscriptionId;
  }

  public subscribeMiniTicker(
    symbol: string,
    market: MarketType = "spot",
    callback?: (data: any) => void
  ) {
    const subscriptionId = `miniTicker_${symbol}_${market}`;
    const message = {
      action: "subscribePublicMiniTicker",
      symbol,
    };

    if (callback) {
      this.callbacks.set(`miniTicker_${symbol}`, callback);
    }

    this.subscriptions.set(subscriptionId, {
      id: subscriptionId,
      action: "subscribePublicMiniTicker",
      symbol,
      market,
      timestamp: Date.now(),
    });

    this.sendMessage(message);
    return subscriptionId;
  }

  // FUTURES
  public subscribeMarkPrice(
    symbol: string,
    market: MarketType = "futures",
    callback?: (data: any) => void
  ) {
    const subscriptionId = `markPrice_${symbol}_${market}`;
    const message = {
      action: "subscribeMarkPrice",
      market,
      symbol,
    };

    if (callback) {
      this.callbacks.set("markPrice", callback);
    }

    this.subscriptions.set(subscriptionId, {
      id: subscriptionId,
      action: "subscribeMarkPrice",
      symbol,
      market,
      timestamp: Date.now(),
    });

    this.sendMessage(message);
    return subscriptionId;
  }

  public subscribeFundingRate(
    symbol: string,
    market: MarketType = "futures",
    callback?: (data: any) => void
  ) {
    const subscriptionId = `fundingRate_${symbol}_${market}`;
    const message = {
      action: "subscribeFundingRate",
      market,
      symbol,
    };

    if (callback) {
      this.callbacks.set("fundingRate", callback);
    }

    this.subscriptions.set(subscriptionId, {
      id: subscriptionId,
      action: "subscribeFundingRate",
      symbol,
      market,
      timestamp: Date.now(),
    });

    this.sendMessage(message);
    return subscriptionId;
  }

  // PRIVATE STREAMS (auth)
  public subscribeAccount(callback?: (data: any) => void) {
    if (!this.isAuthenticated || !this.authToken || !this.binanceAccountId) {
      console.error("‚ùå Authentication required for private streams");
      return null;
    }

    const subscriptionId = `account_${this.binanceAccountId}`;
    const message = {
      action: "subscribePrivateAccount",
      token: this.authToken,
      binanceAccountId: this.binanceAccountId,
    };

    if (callback) {
      this.callbacks.set("account", callback);
    }

    this.subscriptions.set(subscriptionId, {
      id: subscriptionId,
      action: "subscribePrivateAccount",
      timestamp: Date.now(),
    });

    this.sendMessage(message);
    return subscriptionId;
  }

  public subscribeOrders(callback?: (data: any) => void) {
    if (!this.isAuthenticated || !this.authToken || !this.binanceAccountId) {
      console.error("‚ùå Authentication required for private streams");
      return null;
    }

    const subscriptionId = `orders_${this.binanceAccountId}`;
    const message = {
      action: "subscribePrivateOrders",
      token: this.authToken,
      binanceAccountId: this.binanceAccountId,
    };

    if (callback) {
      this.callbacks.set("orders", callback);
    }

    this.subscriptions.set(subscriptionId, {
      id: subscriptionId,
      action: "subscribePrivateOrders",
      timestamp: Date.now(),
    });

    this.sendMessage(message);
    return subscriptionId;
  }

  public subscribeTrades(callback?: (data: any) => void) {
    if (!this.isAuthenticated || !this.authToken || !this.binanceAccountId) {
      console.error("‚ùå Authentication required for private streams");
      return null;
    }

    const subscriptionId = `trades_${this.binanceAccountId}`;
    const message = {
      action: "subscribePrivateTrades",
      token: this.authToken,
      binanceAccountId: this.binanceAccountId,
    };

    if (callback) {
      this.callbacks.set("trades", callback);
    }

    this.subscriptions.set(subscriptionId, {
      id: subscriptionId,
      action: "subscribePrivateTrades",
      timestamp: Date.now(),
    });

    this.sendMessage(message);
    return subscriptionId;
  }

  // ƒêi·ªÅu khi·ªÉn
  public getSubscriptions() {
    const message = {
      action: "getSubscriptions",
    };
    this.sendMessage(message);
    return Array.from(this.subscriptions.values());
  }

  public unsubscribe(connectionId?: string) {
    const message = {
      action: "unsubscribe",
      ...(connectionId && { connectionId }),
    };

    if (connectionId) {
      this.subscriptions.delete(connectionId);
      this.callbacks.delete(connectionId);
    } else {
      this.subscriptions.clear();
      this.callbacks.clear();
    }

    this.sendMessage(message);
  }

  public disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.subscriptions.clear();
    this.callbacks.clear();
    this.onStatusChange("disconnected");
    console.log("üîå WebSocket disconnected");
  }
}

const DEFAULT_SETTINGS: ChartSettings = {
  quickOrder: false,
  pendingOrders: false,
  positionTag: true,   // ƒëang d√πng
  orderHistory: false,
  breakEven: false,
  liquidation: false,
  alerts: false,
  priceLine: false,
  scale: false,
};

export default function TradingTerminal() {
const hasConnectedRef = React.useRef(false);
  
  const [openOrders, setOpenOrders] = useState<Order[]>([]);
  const [positions, setPositions] = useState<PositionData[]>([]);
  const [currentOrders, setCurrentOrders] = useState<Order[]>(() => {
    const stored = localStorage.getItem('openOrders');
    return stored ? JSON.parse(stored) : [];
  });
  const [showSettings, setShowSettings] = useState(false);
  const settingRef = useRef<HTMLDivElement>(null);
  const [orderHistory, setOrderHistory] = useState<Order[]>([]);
  const [selectedAccount, setSelectedAccount] = useState<BinanceAccount | null>(null);
  const [candles, setCandles] = useState<ExtendedCandle[]>([]);
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const [allSymbols, setAllSymbols] = useState<SymbolItem[]>([]);
  const miniTickerCallbacks = useRef<Map<string, (data: MiniTickerData) => void>>(new Map());
  const [searchTerm, setSearchTerm] = useState("");
  const [favoriteSymbols, setFavoriteSymbols] = useState<string[]>(() => {
    const stored = localStorage.getItem("favoriteSymbols");
    return stored ? JSON.parse(stored) : [];
  });
  const [activeSymbolTab, setActiveSymbolTab] = useState<"all" | "favorites">("all");
  const [availableBalance, setAvailableBalance] = useState<number>(0);
  const token = localStorage.getItem("token") || "";
  const [showCancelAllConfirm, setShowCancelAllConfirm] = useState(false);

  // State ch√≠nh
  const [selectedSymbol, setSelectedSymbol] = useState(() => {
    return localStorage.getItem('selectedSymbol') || 'BTCUSDT';
  });
  const [selectedMarket, setSelectedMarket] = useState<MarketType>('futures');
  const [selectedInterval, setSelectedInterval] = useState("1m");
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>("connecting");
  const [wsService] = useState(() => new CustomWebSocketService());
  const miniTickerMap = useMiniTickerStore((state) => state.miniTickerMap);
  const selectedPrice = miniTickerMap[selectedSymbol]?.lastPrice || 0;

  // Market data
  const [klineData, setKlineData] = useState<KlineData | null>(null);
  const [tickerData, setTickerData] = useState<TickerData | null>(null);
  const [orderBook, setOrderBook] = useState<OrderBookData | null>(null);
  const [recentTrades, setRecentTrades] = useState<TradeData[]>([]);
  const [bookTicker, setBookTicker] = useState<BookTickerData | null>(null);
  const [miniTicker, setMiniTicker] = useState<MiniTickerData | null>(null);

  // Account data (private)
  const [accountInfo, setAccountInfo] = useState<AccountInfo | null>(null);
  const [orderUpdates, setOrderUpdates] = useState<OrderUpdate[]>([]);

  // UI
  const [activeOrderTab, setActiveOrderTab] = useState<"limit" | "market" | "stop">("limit");
  const [tradeSide, setTradeSide] = useState<"buy" | "sell">("buy");
  const [subscriptions, setSubscriptions] = useState<Subscription[]>([]);

  // Trading form
  const [price, setPrice] = useState<number>(0);
  const [amount, setAmount] = useState("");
  const [total, setTotal] = useState("");

  const { user } = useAuth() as { user: User };
  const binanceAccountId = user?.internalAccountId;

  const [floatingInfo, setFloatingInfo] = useState<FloatingInfo | null>(null);

  // Toggle control setting
  const [chartSettings, setChartSettings] = React.useState<ChartSettings>(() => {
    try {
      const saved = localStorage.getItem('chartSettings');
      return saved ? { ...DEFAULT_SETTINGS, ...JSON.parse(saved) } : DEFAULT_SETTINGS;
    } catch { return DEFAULT_SETTINGS; }
  });
  const setSetting = React.useCallback(
    (key: keyof ChartSettings, value: boolean) => {
      setChartSettings(prev => {
        const next = { ...prev, [key]: value };
        localStorage.setItem('chartSettings', JSON.stringify(next));
        return next;
      });
    },
    []
  );

  

  // ƒë√≥ng panel setting khi click ngo√†i
  const panelRef = React.useRef<HTMLDivElement>(null);
  React.useEffect(() => {
    if (!showSettings) return;
    const onClick = (e: MouseEvent) => {
      if (!panelRef.current) return;
      if (!panelRef.current.contains(e.target as Node)) setShowSettings(false);
    };
    document.addEventListener('mousedown', onClick);
    return () => document.removeEventListener('mousedown', onClick);
  }, [showSettings]);

  // l∆∞u local symbol
  useEffect(() => {
    if (selectedSymbol) {
      localStorage.setItem('selectedSymbol', selectedSymbol);
    }
  }, [selectedSymbol]);

  const updateCurrentOrders = (orders: Order[]) => {
    setOpenOrders(orders);
    localStorage.setItem('openOrders', JSON.stringify(orders));
  };

  // ƒë√≥ng menu setting khi click ra ngo√†i
  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (settingRef.current && !settingRef.current.contains(e.target as Node)) {
        setShowSettings(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // ‚úÖ D√πng m·ªôt handler duy nh·∫•t cho openOrders (tr√°nh ghi ƒë√®)
  useEffect(() => {
    binanceWS.setOrderUpdateHandler((orders: any[]) => {
      // service ƒë√£ chu·∫©n ho√° localStorage; ·ªü ƒë√¢y ch·ªâ sync state
      setOpenOrders(orders || []);
    });
    return () => {
      binanceWS.setOrderUpdateHandler(null);
    };
  }, []);

  // Khi ƒë·ªïi th·ªã tr∆∞·ªùng ‚Üí k√©o account info t∆∞∆°ng ·ª©ng
  useEffect(() => {
    if (!selectedAccount?.id) return;
    if (selectedMarket === "futures") {
      binanceWS.getFuturesAccount(selectedAccount.id);
    } else {
      binanceWS.getSpotAccount(selectedAccount.id);
    }
  }, [selectedMarket, selectedAccount?.id]);

  // Handler WS t·ªïng (kh√¥ng ch·ªçn account ·ªü ƒë√¢y ƒë·ªÉ tr√°nh double-select)
  const globalWsHandler = useCallback((msg: any) => {
    console.log("üì• WS Message:", msg);

    switch (msg.type) {
      case "authenticated": {
        // service clean s·∫Ω t·ª± flush queue sau authenticated
        break;
      }
      // ‚ùå B·ªé ch·ªçn account ·ªü ƒë√¢y ƒë·ªÉ tr√°nh double select
      // case "myBinanceAccounts": { ... }

      case "cancelAllOrdersSuccess":
        toast.success("Hu·ª∑ t·∫•t c·∫£ l·ªánh th√†nh c√¥ng!");
        break;

      case "cancelAllOrdersFailed":
        toast.error("Hu·ª∑ t·∫•t c·∫£ l·ªánh th·∫•t b·∫°i!");
        break;

      case "futuresDataLoaded":
      case "balances": {
        const usdt = msg.data?.balances?.find((b: any) => b.asset === "USDT");
        if (usdt) setAvailableBalance(parseFloat(usdt.availableBalance || "0"));
        break;
      }
      default:
        break;
    }
  }, []);

  // 3) useEffect connect (ƒë·∫∑t SAU handler)
React.useEffect(() => {
  if (!token) return;
  if (hasConnectedRef.current) return;
  hasConnectedRef.current = true;

  binanceWS.connect(token, globalWsHandler);
}, [token, globalWsHandler]);

  // K·∫øt n·ªëi WS trading (service ch√≠nh) 1 l·∫ßn
  useEffect(() => {
    if (!token) return;
    binanceWS.connect(token, globalWsHandler);
  }, [token, globalWsHandler]);

  const handleCancelAllOrders = () => {
    binanceWS.cancelAllOrders(selectedSymbol, selectedMarket);
    setShowCancelAllConfirm(false);
  };

  // T·∫£i d·ªØ li·ªáu n·∫øn l·ªãch s·ª≠ ban ƒë·∫ßu
  useEffect(() => {
    let isMounted = true;

    const loadHistoricalKlines = async () => {
      try {
        const historicalData = await fetchHistoricalKlines(
          selectedSymbol,
          selectedInterval,
          500
        );
        if (isMounted) {
          setCandles(historicalData);
        }
      } catch (error) {
        console.error("‚ùå Failed to fetch historical klines:", error);
      }
    };

    loadHistoricalKlines();

    return () => {
      isMounted = false;
    };
  }, [selectedSymbol, selectedInterval]);

  // Kh·ªüi t·∫°o WS ph·ª• (public streams cho panel b√™n) ‚Äî ƒë√£ b·ªè Kline ·ªü ƒë√¢y ƒë·ªÉ tr√°nh subscribe tr√πng
  useEffect(() => {
    wsService.setStatusCallback(setConnectionStatus);

    const subscriptionIds: string[] = [];

    // 1) 24h Ticker
    const tickerId = wsService.subscribeTicker(
      selectedSymbol,
      selectedMarket,
      (data) => {
        if (data.symbol !== selectedSymbol) return;
        setTickerData(data);
      }
    );
    if (tickerId) subscriptionIds.push(tickerId);

    // 2) Order Book Depth
    const depthId = wsService.subscribeDepth(
      selectedSymbol,
      "20",
      "1000ms",
      selectedMarket,
      (data) => {
        if (data.symbol !== selectedSymbol) return;
        setOrderBook(data);
      }
    );
    if (depthId) subscriptionIds.push(depthId);

    // 3) Trade Stream
    const tradeId = wsService.subscribeTrade(
      selectedSymbol,
      selectedMarket,
      (data) => {
        if (data.symbol !== selectedSymbol) return;

        const trade: TradeData = {
          symbol: data.symbol,
          tradeId: data.tradeId,
          price: data.price?.toString() ?? "0",
          qty: data.quantity?.toString() ?? "0",
          time: data.tradeTime ?? Date.now(),
          isBuyerMaker: data.isBuyerMaker,
        };

        setRecentTrades((prev) => {
          const newTrades = [trade, ...prev.slice(0, 49)];
          return newTrades.sort((a, b) => b.time - a.time);
        });
      }
    );
    if (tradeId) subscriptionIds.push(tradeId);

    // 4) Book Ticker
    const bookTickerId = wsService.subscribeBookTicker(
      selectedSymbol,
      selectedMarket,
      (data) => {
        if (data.symbol !== selectedSymbol) return;
        setBookTicker(data);
      }
    );
    if (bookTickerId) subscriptionIds.push(bookTickerId);

    // 5) Mini Ticker cho symbol ƒëang ch·ªçn (l∆∞u id ƒë·ªÉ cleanup)
    const miniId = wsService.subscribeMiniTicker(
      selectedSymbol,
      selectedMarket,
      (data) => {
        if (data.symbol !== selectedSymbol) return;
        setPrice(parseFloat(data.close));
      }
    );
    if (miniId) subscriptionIds.push(miniId);

    // c·∫≠p nh·∫≠t danh s√°ch subscriptions (th√¥ng tin hi·ªÉn th·ªã)
    setSubscriptions(wsService.getSubscriptions());

    return () => {
      // cleanup c√°c stream ƒë√£ ƒëƒÉng k√Ω trong effect n√†y
      subscriptionIds.forEach((id) => {
        wsService.unsubscribe(id);
      });
    };
  }, [selectedSymbol, selectedMarket, selectedInterval]);

  // Stream Kline duy nh·∫•t ‚Üí c·∫≠p nh·∫≠t candles + (tu·ª≥ ch·ªçn) overlay klineData
  useEffect(() => {
    const klineId = wsService.subscribeKline(
      selectedSymbol,
      selectedInterval,
      selectedMarket,
      (data) => {
        if (data.symbol !== selectedSymbol) return;

        // set overlay cho panel th√¥ng tin (n·∫øu c·∫ßn)
        setKlineData(data);

        const newCandle: ExtendedCandle = {
          time: Math.floor(data.openTime / 1000),
          open: parseFloat(data.open),
          high: parseFloat(data.high),
          low: parseFloat(data.low),
          close: parseFloat(data.close),
          volume: parseFloat(data.volume),
        };

        setCandles((prev) => {
          const exists = prev.find((c) => c.time === newCandle.time);
          let updated = exists
            ? prev.map((c) => (c.time === newCandle.time ? newCandle : c))
            : [...prev, newCandle];

          if (updated.length > 500) updated = updated.slice(-500);
          return updated;
        });
      }
    );

    return () => {
      wsService.unsubscribe(klineId);
    };
  }, [selectedSymbol, selectedInterval, selectedMarket]);

  // Stream miniTicker cho to√†n b·ªô symbolList ƒë·ªÉ render danh s√°ch ‚Äî cleanup ƒë√∫ng
  useEffect(() => {
    const ids: string[] = [];

    symbolList.forEach((sym) => {
      const callback = (data: MiniTickerData) => {
        const symbol = data.symbol?.toUpperCase?.();
        const close = parseFloat(data.close);
        const open = parseFloat(data.open);
        const percentChange = open !== 0 ? ((close - open) / open) * 100 : 0;

        // b·ªè qua symbol ƒëang ch·ªçn
        if (symbol === selectedSymbol) return;

        setAllSymbols((prev) => {
          const updated = prev.filter((s) => s.symbol !== symbol);
          return [
            ...updated,
            {
              symbol,
              price: close,
              percentChange,
              volume: parseFloat(data.volume),
            },
          ];
        });
      };

      const id = wsService.subscribeMiniTicker(sym, selectedMarket, callback);
      ids.push(id);
    });

    return () => {
      ids.forEach((id) => wsService.unsubscribe(id));
    };
  }, [selectedMarket, selectedSymbol]);

  const sortedSymbols: SymbolItem[] = symbolList.map((symbol) => {
    const matched = allSymbols.find((s) => s.symbol === symbol);
    return (
      matched ?? {
        symbol,
        price: 0,
        percentChange: 0,
        volume: 0,
      }
    );
  });

  // ‚úÖ Subscribe realtime theo account ƒë√£ ch·ªçn (th√™m ref-guard ch·ªëng duplicate)
  const subOnceRef = useRef<number | null>(null);
  useEffect(() => {
    const id = selectedAccount?.id;
    if (!id) return;

    const now = Date.now();
    if (subOnceRef.current && now - subOnceRef.current < 1500) return;
    subOnceRef.current = now;

    // 1) ch·ªçn account
    binanceWS.selectAccount(id);

    // 2) subscribe realtime (balance/positions/orders)
    binanceWS.subscribeAccountUpdates(setOpenOrders, ['balance','positions','orders']);

    // 3) k√©o positions tr∆∞·ªõc m·ªôt nh·ªãp
    binanceWS.getPositions(id);

    // 4) c·∫≠p nh·∫≠t positions t·ª´ snapshot/stream
    binanceWS.setPositionUpdateHandler((rawPositions: any[]) => {
      const active = (rawPositions || []).filter((p: any) => parseFloat(p.positionAmt) !== 0);
      setPositions(active);
      localStorage.setItem('positions', JSON.stringify(active));
    });

    return () => {
      binanceWS.unsubscribeAccountUpdates();
    };
  }, [selectedAccount?.id]);

  // Kh√¥i ph·ª•c account ƒë√£ ch·ªçn t·ª´ localStorage khi v√†o trang (ch·ªâ 1 l·∫ßn)
  useEffect(() => {
    const savedId = localStorage.getItem('selectedBinanceAccountId');
    const parsedId = savedId ? parseInt(savedId, 10) : null;
    if (!parsedId) return;

    const restore = () => {
      binanceWS.setCurrentAccountId(parsedId);
      binanceWS.selectAccount(parsedId);
      binanceWS.getMultiAssetsMode();
      setSelectedAccount({ id: parsedId } as BinanceAccount);
    };

    const timer = setTimeout(() => {
      if (binanceWS.isConnected()) {
        restore();
      } else {
        const waitInterval = setInterval(() => {
          if (binanceWS.isConnected()) {
            clearInterval(waitInterval);
            restore();
          }
        }, 200);
      }
    }, 300);

    return () => clearTimeout(timer);
  }, []);

  const handleUnsubscribe = (subscriptionId: string) => {
    wsService.unsubscribe(subscriptionId);
    setSubscriptions(wsService.getSubscriptions());
  };

  const handleClickOrderBookPrice = (price: number) => {
    setPrice(price);
  };

  const handleSymbolChange = (newSymbol: string) => {
    setSelectedSymbol(newSymbol);
  };

  const handleMarketChange = (newMarket: MarketType) => {
    setSelectedMarket(newMarket);
    localStorage.setItem('selectedMarket', newMarket);
    console.log("‚úÖ Market selected:", newMarket);
  };
  useEffect(() => {
    const savedMarket = localStorage.getItem('selectedMarket');
    if (savedMarket === 'spot' || savedMarket === 'futures') {
      setSelectedMarket(savedMarket as MarketType);
    }
  }, []);

  const handleIntervalChange = (newInterval: string) => {
    setSelectedInterval(newInterval);
  };

  const calculateTotal = (price: string, amount: string) => {
    if (price && amount) {
      const calculatedTotal = parseFloat(price) * parseFloat(amount);
      return calculatedTotal.toFixed(8);
    }
    return "";
  };

  const handleAmountChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newAmount = e.target.value;
    setAmount(newAmount);
    setTotal(calculateTotal(String(price), newAmount));
  };

  const handlePriceChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newPrice = e.target.value;
    setPrice(Number(newPrice));
    setTotal(calculateTotal(newPrice, amount));
  };

  const handleTotalChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newTotal = e.target.value;
    setTotal(newTotal);

    if (newTotal && price && parseFloat(String(price)) !== 0) {
      const calculatedAmount = (
        parseFloat(newTotal) / parseFloat(String(price))
      ).toFixed(8);
      setAmount(calculatedAmount);
    } else {
      setAmount("");
    }
  };

  return (
    <div className="h-[calc(100dvh-4rem)] bg-dark-900 flex flex-col">
      {/* Thanh tr√™n c√πng: ch·ªçn symbol + tr·∫°ng th√°i + t√†i kho·∫£n */}
      <div className="shrink-0 border-b border-dark-700 bg-dark-800">
        <div className="flex items-center justify-between px-4 py-2">
          {/* Tr√°i: ch·ªçn symbol + stats nhanh */}
          <div className="flex items-center space-x-6">
            <div className="flex items-center">
              <div className="relative z-50">
                {/* N√∫t ch·ªçn symbol */}
                <button
                  className="flex items-center space-x-2 hover:bg-dark-700 px-3 py-2 rounded"
                  onClick={() => setIsDropdownOpen((prev) => !prev)}
                >
                  <div className="h-6 w-6 rounded-full bg-warning-300 flex items-center justify-center">
                    <span className="text-xs font-bold text-dark-900">
                      {selectedSymbol[0]}
                    </span>
                  </div>
                  <span className="font-bold text-lg">{selectedSymbol}</span>
                  <ChevronDown className="h-4 w-4 text-dark-400" />
                </button>

                {/* Menu dropdown symbol */}
                {isDropdownOpen && (
                  <div className="absolute top-full left-0 mt-2 w-[350px] max-h-[500px] bg-dark-800 rounded shadow-lg overflow-y-auto z-[999] border border-dark-700">
                    <SymbolDropdown
                      symbols={sortedSymbols}
                      selectedSymbol={selectedSymbol}
                      favorites={favoriteSymbols}
                      searchTerm={searchTerm}
                      activeTab={activeSymbolTab}
                      onSelect={(s) => {
                        setSelectedSymbol(s);
                        setIsDropdownOpen(false);
                      }}
                      onToggleFavorite={(symbol) => {
                        setFavoriteSymbols((prev) =>
                          prev.includes(symbol)
                            ? prev.filter((s) => s !== symbol)
                            : [...prev, symbol]
                        );
                      }}
                      onSearchChange={setSearchTerm}
                      onTabChange={setActiveSymbolTab}
                    />
                  </div>
                )}
              </div>

              <Star className="h-4 w-4 text-dark-400 hover:text-warning-300 ml-2 cursor-pointer" />
            </div>

            {/* Ch·ªçn market */}
            <div className="flex items-center space-x-2">
              <span className="text-xs text-dark-400">Market:</span>
              <select
                value={selectedMarket}
                onChange={(e) =>
                  handleMarketChange(e.target.value as 'spot' | 'futures')
                }
                className="bg-dark-700 border border-dark-600 rounded px-2 py-1 text-xs focus:border-primary-500 focus:outline-none"
              >
                <option value="futures">FUTURES</option>
                <option value="spot">SPOT</option>
              </select>
            </div>

            {/* Hi·ªÉn th·ªã gi√° + thay ƒë·ªïi 24h */}
            {tickerData && (
              <>
                <div className="flex flex-col">
                  <span className="text-lg font-bold">
                    {parseFloat(tickerData.lastPrice).toFixed(4)}
                  </span>
                  <span className="text-xs text-dark-400">
                    ‚âà ${parseFloat(tickerData.lastPrice).toFixed(2)}
                  </span>
                </div>

                <div className="flex flex-col">
                  <span
                    className={`text-sm font-medium ${
                      parseFloat(tickerData.priceChange) >= 0
                        ? "text-success-500"
                        : "text-danger-500"
                    }`}
                  >
                    {parseFloat(tickerData.priceChange) >= 0 ? "+" : ""}
                    {parseFloat(tickerData.priceChange).toFixed(4)}
                  </span>
                  <span
                    className={`text-xs ${
                      parseFloat(tickerData.priceChangePercent) >= 0
                        ? "text-success-500"
                        : "text-danger-500"
                    }`}
                  >
                    {parseFloat(tickerData.priceChangePercent) >= 0 ? "+" : ""}
                    {tickerData.priceChangePercent}%
                  </span>
                </div>
              </>
            )}
          </div>

          {/* Ph·∫£i: tr·∫°ng th√°i k·∫øt n·ªëi + ch·ªçn t√†i kho·∫£n + controls */}
          <div className="flex items-center space-x-4">
            <div className="flex items-center space-x-2">
              {connectionStatus === "connected" ? (
                <Wifi className="h-4 w-4 text-success-500" />
              ) : connectionStatus === "connecting" ? (
                <div className="h-4 w-4 border-2 border-primary-500 border-t-transparent rounded-full animate-spin" />
              ) : (
                <WifiOff className="h-4 w-4 text-danger-500" />
              )}
              <span className="text-xs text-dark-400 capitalize">
                {connectionStatus}
              </span>
            </div>

            {/* T√†i kho·∫£n Binance ƒëang ch·ªçn */}
            <div className="flex items-center space-x-2">
              <span className="text-xs text-dark-400">T√†i kho·∫£n:</span>
              <BinanceAccountSelector
                onSelect={(id) => {
                  setSelectedAccount({ id });
                }}
              />
            </div>

            <div className="text-xs text-dark-400">
              Subscriptions: {subscriptions.length}
            </div>

            <button
              onClick={() => wsService.getSubscriptions()}
              className="p-1 hover:bg-dark-700 rounded"
            >
              <RefreshCw className="h-4 w-4 text-dark-400" />
            </button>

            <button className="p-1 hover:bg-dark-700 rounded">
              <Settings className="h-4 w-4 text-dark-400" />
            </button>
          </div>
        </div>

        {/* D·∫£i stats 24h */}
        {tickerData && (
          <div className="flex items-center space-x-8 px-4 py-2 text-xs border-t border-dark-700">
            <div className="flex flex-col">
              <span className="text-dark-400">24h High</span>
              <span className="font-medium">
                {parseFloat(tickerData.highPrice).toFixed(4)}
              </span>
            </div>
            <div className="flex flex-col">
              <span className="text-dark-400">24h Low</span>
              <span className="font-medium">
                {parseFloat(tickerData.lowPrice).toFixed(4)}
              </span>
            </div>
            <div className="flex flex-col">
              <span className="text-dark-400">
                24h Volume ({selectedSymbol.replace("USDT", "")})
              </span>
              <span className="font-medium">
                {parseFloat(tickerData.volume).toLocaleString()}
              </span>
            </div>
            <div className="flex flex-col">
              <span className="text-dark-400">24h Volume (USDT)</span>
              <span className="font-medium">
                {parseFloat(tickerData.quoteVolume).toLocaleString()}
              </span>
            </div>
          </div>
        )}
      </div>

      {/* Th√¢n ch√≠nh: Chart tr√°i, Order book gi·ªØa, Form ph·∫£i */}
      <div className="flex gap-1 flex-1 min-h-0 overflow-hidden">
        {/* Tr√°i: Bi·ªÉu ƒë·ªì */}
        <div className="flex-1 min-w-0 bg-dark-800 border-r border-dark-700 overflow-hidden">
          <div className="h-full flex flex-col">
            {/* Controls chart */}
            <div className="flex items-center justify-between p-3 border-b border-dark-700">
              <div className="flex items-center space-x-4">
                <div className="flex items-center space-x-2">
                  {["1m", "3m", "5m", "15m", "30m", "1h", "4h", "1d"].map(
                    (interval) => (
                      <button
                        key={interval}
                        onClick={() => handleIntervalChange(interval)}
                        className={`text-xs px-2 py-1 rounded hover:bg-dark-600 ${
                          selectedInterval === interval ? "bg-dark-700" : ""
                        }`}
                      >
                        {interval}
                      </button>
                    )
                  )}
                </div>

                <div className="relative" ref={settingRef}>
                  <div className="flex items-center gap-2">
                    <button className="btn">Candlesticks</button>
                    <button className="btn">Line</button>

                    <div className="flex items-center gap-2 mb-2 relative" ref={panelRef}>
                      <button
                        className="btn-outline p-2 hover:ring-1 ring-primary-500 rounded-md"
                        title="C√†i ƒë·∫∑t bi·ªÉu ƒë·ªì"
                        onClick={() => setShowSettings(v => !v)}
                      >
                        <Settings size={15} />
                      </button>

                      {showSettings && (
                        <div className="absolute top-full left-0 mt-2 z-50">
                          <SettingControl
                            settings={chartSettings}
                            onToggle={setSetting}
                            onClose={() => setShowSettings(false)}
                          />
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>

              <div className="flex items-center space-x-2">
                <button className="p-1 hover:bg-dark-700 rounded">
                  <TrendingUp className="h-4 w-4 text-dark-400" />
                </button>
                <button className="p-1 hover:bg-dark-700 rounded">
                  <Maximize2 className="h-4 w-4 text-dark-400" />
                </button>
              </div>
            </div>

            {/* Khu v·ª±c bi·ªÉu ƒë·ªì */}
            <div className="flex-1 relative min-h-0">
              <section className="h-full min-w-0 bg-dark-800 rounded-xl overflow-hidden">
                <div className="h-full min-h-0">
                  <TradingBinance
                    selectedSymbol={selectedSymbol}
                    selectedInterval={selectedInterval}
                    market={selectedMarket}
                    floating={floatingInfo}
                    showPositionTag={chartSettings.positionTag}
                    onRequestSymbolChange={(sym) => setSelectedSymbol(sym)}
                  />
                </div>
              </section>

              {/* Overlay OHLCV */}
              <div className="absolute top-4 left-4 bg-dark-800/80 rounded p-2 text-xs z-10">
                {klineData && (
                  <div className="space-y-1">
                    <div>
                      O:{" "}
                      <span className="font-mono">
                        {parseFloat(klineData.open || "0").toFixed(2)}
                      </span>
                    </div>
                    <div>
                      H:{" "}
                      <span className="font-mono text-success-500">
                        {parseFloat(klineData.high || "0").toFixed(2)}
                      </span>
                    </div>
                    <div>
                      L:{" "}
                      <span className="font-mono text-danger-500">
                        {parseFloat(klineData.low || "0").toFixed(2)}
                      </span>
                    </div>
                    <div>
                      C:{" "}
                      <span className="font-mono">
                        {parseFloat(klineData.close || "0").toFixed(2)}
                      </span>
                    </div>
                    <div>
                      V:{" "}
                      <span className="font-mono">
                        {parseFloat(klineData.volume || "0").toLocaleString()}
                      </span>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>

        {/* Gi·ªØa: Order Book */}
        <div className="min-h-0 w-56 md:w-64 bg-dark-800 border-r border-dark-700">
          <div className="h-full flex flex-col">
            <div className="flex items-center justify-between p-3 border-b border-dark-700">
              <h3 className="text-sm font-medium">Order Book</h3>
              <div className="flex items-center space-x-2">
                <button className="text-xs text-dark-400 hover:text-dark-200">
                  0.01
                </button>
                <Settings className="h-3 w-3 text-dark-400" />
              </div>
            </div>

            <div className="flex-1 overflow-hidden">
              {orderBook ? (
                <div className="h-full flex flex-col">
                  {/* Asks */}
                  <div className="flex-1 overflow-y-auto">
                    <div className="space-y-0.5 p-2">
                      {orderBook.asks
                        .slice(0, 15)
                        .reverse()
                        .map((ask, index) => (
                          <div
                            key={index}
                            className="flex justify-between text-xs relative cursor-pointer hover:bg-dark-700"
                            onClick={() =>
                              handleClickOrderBookPrice(parseFloat(ask.price))
                            }
                          >
                            <span className="text-danger-500 font-mono">
                              {parseFloat(ask.price).toFixed(4)}
                            </span>
                            <span className="text-dark-300 font-mono">
                              {parseFloat(ask.quantity).toFixed(3)}
                            </span>
                            <div
                              className="absolute right-0 top-0 h-full bg-danger-500/10"
                              style={{
                                width: `${Math.min(
                                  (parseFloat(ask.quantity) / 10) * 100,
                                  100
                                )}%`,
                              }}
                            />
                          </div>
                        ))}
                    </div>
                  </div>

                  {/* Gi√° hi·ªán t·∫°i */}
                  <div className="px-2 py-1 border-y border-dark-700">
                    <div className="text-center">
                      <div
                        className={`text-sm font-bold ${
                          tickerData && parseFloat(tickerData.priceChange) >= 0
                            ? "text-success-500"
                            : "text-danger-500"
                        }`}
                      >
                        {tickerData
                          ? parseFloat(tickerData.lastPrice).toFixed(4)
                          : "0.0000"}
                      </div>
                      <div className="text-xs text-dark-400">
                        ‚âà $
                        {tickerData
                          ? parseFloat(tickerData.lastPrice).toFixed(2)
                          : "0.00"}
                      </div>
                    </div>
                  </div>

                  {/* Bids */}
                  <div className="flex-1 overflow-y-auto">
                    <div className="space-y-0.5 p-2">
                      {orderBook.bids.slice(0, 15).map((bid, index) => (
                        <div
                          key={index}
                          className="flex justify-between text-xs relative cursor-pointer hover:bg-dark-700"
                          onClick={() =>
                            handleClickOrderBookPrice(parseFloat(bid.price))
                          }
                        >
                          <span className="text-success-500 font-mono">
                            {parseFloat(bid.price).toFixed(4)}
                          </span>
                          <span className="text-dark-300 font-mono">
                            {parseFloat(bid.quantity).toFixed(3)}
                          </span>
                          <div
                            className="absolute right-0 top-0 h-full bg-success-500/10"
                            style={{
                              width: `${Math.min(
                                (parseFloat(bid.quantity) / 10) * 100,
                                100
                              )}%`,
                            }}
                          />
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              ) : (
                <div className="flex items-center justify-center h-full text-dark-400">
                  <div className="text-center">
                    <div className="text-sm">No order book data</div>
                    <div className="text-xs mt-1">
                      Waiting for WebSocket connection...
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Ph·∫£i: Form ƒë·∫∑t l·ªánh + (optional) Recent trades */}
        <div className="min-h-0 w-64 md:w-72 lg:w-80 bg-dark-800 border-l border-dark-700 flex flex-col">
          <div className="flex-1 min-h-0 overflow-y-auto">
            <TradingForm
              selectedSymbol={selectedSymbol}
              price={price}
              internalBalance={availableBalance}
              selectedMarket={selectedMarket}
            />
          </div>
        </div>
      </div>

      {/* Panel d∆∞·ªõi: Positions/Orders */}
      <div className="shrink-0 h-[28dvh] min-h-[220px] max-h-[40dvh] border-t border-dark-700 bg-dark-800 overflow-hidden">
        <div className="h-full overflow-y-auto">
          <PositionFunction
            market={selectedMarket}
            selectedSymbol={selectedSymbol}
            orderBook={orderBook}
            positions={positions}
            onFloatingInfoChange={setFloatingInfo}
          />
        </div>
      </div>
    </div>
  );
}
